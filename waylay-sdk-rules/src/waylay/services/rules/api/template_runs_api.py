# coding: utf-8
"""Waylay rules engine api.

This code was generated from the OpenAPI documentation of 'Waylay rules engine'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

from __future__ import annotations  # for Python 3.7â€“3.9

from typing import (
    TYPE_CHECKING,
    Any,
    AsyncIterator,
    Dict,
    Literal,
    TypeVar,
    overload,
)

from pydantic import (
    Field,
    StrictBool,
    StrictStr,
    TypeAdapter,
)
from typing_extensions import (
    Annotated,  # >=3.9,
)
from waylay.sdk.api import (
    HeaderTypes,
    QueryParamTypes,
    Response,
)
from waylay.sdk.api._models import Model
from waylay.sdk.api.constants import STREAM_TIMEOUTS
from waylay.sdk.plugin import WithApiClient

if TYPE_CHECKING:
    from waylay.services.rules.models import (
        ErrorResponse,
        ErrorWithDetailsResponse,
        TemplateRunInvocation,
        TemplateRunSpecification,
        TemplateRunWithGraphSpecification,
    )
    from waylay.services.rules.queries.template_runs_api import RunGraphQuery, RunQuery


try:
    from waylay.services.rules.models import (
        ErrorResponse,
        ErrorWithDetailsResponse,
        TemplateRunInvocation,
        TemplateRunSpecification,
        TemplateRunWithGraphSpecification,
    )
    from waylay.services.rules.queries.template_runs_api import RunGraphQuery, RunQuery

    MODELS_AVAILABLE = True
except ImportError:
    MODELS_AVAILABLE = False

    if not TYPE_CHECKING:
        TemplateRunWithGraphSpecification = Model

        RunGraphQuery = dict
        TemplateRunInvocation = Model

        ErrorWithDetailsResponse = Model

        TemplateRunSpecification = Model

        RunQuery = dict
        TemplateRunInvocation = Model

        ErrorWithDetailsResponse = Model

        ErrorResponse = Model


T = TypeVar("T")


class TemplateRunsApi(WithApiClient):
    """TemplateRunsApi service methods.

    NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    @overload
    async def run_graph(
        self,
        *,
        json: Annotated[
            TemplateRunWithGraphSpecification,
            Field(description="Specification to run template through graph/BN."),
        ],
        query: RunGraphQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        stream: bool = True,
        timeout=STREAM_TIMEOUTS,
        **kwargs,
    ) -> AsyncIterator[TemplateRunInvocation]: ...

    @overload
    async def run_graph(
        self,
        *,
        json: Annotated[
            TemplateRunWithGraphSpecification,
            Field(description="Specification to run template through graph/BN."),
        ],
        query: RunGraphQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        stream: bool = True,
        timeout=STREAM_TIMEOUTS,
        **kwargs,
    ) -> AsyncIterator[T]: ...

    @overload
    async def run_graph(
        self,
        *,
        json: Annotated[
            TemplateRunWithGraphSpecification,
            Field(description="Specification to run template through graph/BN."),
        ],
        query: RunGraphQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        stream: bool = True,
        timeout=STREAM_TIMEOUTS,
        **kwargs,
    ) -> Response: ...

    @overload
    async def run_graph(
        self,
        *,
        json: Annotated[
            TemplateRunWithGraphSpecification,
            Field(description="Specification to run template through graph/BN."),
        ],
        query: RunGraphQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        stream: bool = True,
        timeout=STREAM_TIMEOUTS,
        **kwargs,
    ) -> AsyncIterator[Model]: ...

    @overload
    async def run_graph(
        self,
        *,
        json: Annotated[
            TemplateRunWithGraphSpecification,
            Field(description="Specification to run template through graph/BN."),
        ],
        query: RunGraphQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        stream: bool = True,
        timeout=STREAM_TIMEOUTS,
        **kwargs,
    ) -> AsyncIterator[T]: ...

    async def run_graph(
        self,
        *,
        json: Annotated[
            TemplateRunWithGraphSpecification,
            Field(description="Specification to run template through graph/BN."),
        ],
        query: RunGraphQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        stream: bool = True,
        timeout=STREAM_TIMEOUTS,
        **kwargs,
    ) -> (
        AsyncIterator[TemplateRunInvocation]
        | AsyncIterator[T]
        | Response
        | AsyncIterator[Model]
    ):
        """Run Graph Or Bayesian Network.

        Run a graph or Bayesian Network. If `data` is specified, template will be run as reactive template. If `data` is not specified, template will be run as a one-time template (1 tick)
        :param json: Specification to run template through graph/BN.
        :type json: TemplateRunWithGraphSpecification, optional
        :param query: URL Query parameters.
        :type query: RunGraphQuery | QueryParamTypes, optional
        :param query['logLevel'] (dict) <br> query.log_level (Query) : sets the log level for filtering out logs to requested log level or higher from the template run output. Value `NONE` will disable all logs. If not specified all logs will be returned.
        :type query['logLevel']: RunTemplateLogLevelParameter
        :param query['targetNode'] (dict) <br> query.target_node (Query) : The sensors and actuators part of response will contain only elements related to the asked node of the graph. The returned logs also will be filtered and contain only logs related to the asked node(s).
        :type query['targetNode']: List[str]
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {}

        ## named body parameters
        body_args: Dict[str, Any] = {}
        if json is not None and validate_request:
            body_adapter: Any = TypeAdapter(
                Annotated[
                    TemplateRunWithGraphSpecification,
                    Field(
                        description="Specification to run template through graph/BN."
                    ),
                ]
            )
            json = body_adapter.validate_python(json)  # type: ignore # https://github.com/pydantic/pydantic/discussions/7094
        body_args["json"] = json

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(RunGraphQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": TemplateRunInvocation if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {
            "400": ErrorWithDetailsResponse,
        }
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="POST",
            resource_path="/rules/v1/templates/run",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            stream=stream,
            timeout=timeout,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def run(
        self,
        name: Annotated[StrictStr, Field(description="Unique Template identifier")],
        *,
        json: Annotated[
            TemplateRunSpecification, Field(description="Specification to run template")
        ],
        query: RunQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        stream: bool = True,
        timeout=STREAM_TIMEOUTS,
        **kwargs,
    ) -> AsyncIterator[TemplateRunInvocation]: ...

    @overload
    async def run(
        self,
        name: Annotated[StrictStr, Field(description="Unique Template identifier")],
        *,
        json: Annotated[
            TemplateRunSpecification, Field(description="Specification to run template")
        ],
        query: RunQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        stream: bool = True,
        timeout=STREAM_TIMEOUTS,
        **kwargs,
    ) -> AsyncIterator[T]: ...

    @overload
    async def run(
        self,
        name: Annotated[StrictStr, Field(description="Unique Template identifier")],
        *,
        json: Annotated[
            TemplateRunSpecification, Field(description="Specification to run template")
        ],
        query: RunQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        stream: bool = True,
        timeout=STREAM_TIMEOUTS,
        **kwargs,
    ) -> Response: ...

    @overload
    async def run(
        self,
        name: Annotated[StrictStr, Field(description="Unique Template identifier")],
        *,
        json: Annotated[
            TemplateRunSpecification, Field(description="Specification to run template")
        ],
        query: RunQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        stream: bool = True,
        timeout=STREAM_TIMEOUTS,
        **kwargs,
    ) -> AsyncIterator[Model]: ...

    @overload
    async def run(
        self,
        name: Annotated[StrictStr, Field(description="Unique Template identifier")],
        *,
        json: Annotated[
            TemplateRunSpecification, Field(description="Specification to run template")
        ],
        query: RunQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        stream: bool = True,
        timeout=STREAM_TIMEOUTS,
        **kwargs,
    ) -> AsyncIterator[T]: ...

    async def run(
        self,
        name: Annotated[StrictStr, Field(description="Unique Template identifier")],
        *,
        json: Annotated[
            TemplateRunSpecification, Field(description="Specification to run template")
        ],
        query: RunQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        validate_request: StrictBool = True,
        headers: HeaderTypes | None = None,
        stream: bool = True,
        timeout=STREAM_TIMEOUTS,
        **kwargs,
    ) -> (
        AsyncIterator[TemplateRunInvocation]
        | AsyncIterator[T]
        | Response
        | AsyncIterator[Model]
    ):
        """Run Template.

        Run a template. If `data` is specified, template will be run as reactive template. If `data` is not specified, template will be run as a one-time template (1 tick)
        :param name: Unique Template identifier (required)
        :type name: str
        :param json: Specification to run template
        :type json: TemplateRunSpecification, optional
        :param query: URL Query parameters.
        :type query: RunQuery | QueryParamTypes, optional
        :param query['logLevel'] (dict) <br> query.log_level (Query) : sets the log level for filtering out logs to requested log level or higher from the template run output. Value `NONE` will disable all logs. If not specified all logs will be returned.
        :type query['logLevel']: RunTemplateLogLevelParameter
        :param query['targetNode'] (dict) <br> query.target_node (Query) : The sensors and actuators part of response will contain only elements related to the asked node of the graph. The returned logs also will be filtered and contain only logs related to the asked node(s).
        :type query['targetNode']: List[str]
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param validate_request: If set to false, the request body and query parameters are NOT validated against the models in the service types package, even when available.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        # path parameters
        path_params: Dict[str, str] = {
            "name": str(name),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}
        if json is not None and validate_request:
            body_adapter: Any = TypeAdapter(
                Annotated[
                    TemplateRunSpecification,
                    Field(description="Specification to run template"),
                ]
            )
            json = body_adapter.validate_python(json)  # type: ignore # https://github.com/pydantic/pydantic/discussions/7094
        body_args["json"] = json

        # query parameters
        if query is not None and MODELS_AVAILABLE and validate_request:
            query = TypeAdapter(RunQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": TemplateRunInvocation if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {
            "400": ErrorWithDetailsResponse,
            "404": ErrorResponse,
        }
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="POST",
            resource_path="/rules/v1/templates/{name}/run",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            stream=stream,
            timeout=timeout,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )
