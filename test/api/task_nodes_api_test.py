# coding: utf-8
"""Waylay rules engine api tests.

This code was generated from the OpenAPI documentation of 'Waylay rules engine'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import json
import re
from importlib.util import find_spec
from typing import Union
from urllib.parse import quote

import pytest
from pytest_httpx import HTTPXMock
from typeguard import check_type
from waylay.sdk import ApiClient, WaylayClient
from waylay.sdk.api._models import Model
from waylay.services.rules.api import TaskNodesApi
from waylay.services.rules.service import RulesService

from ..types.node_state_specification_stub import NodeStateSpecificationStub

MODELS_AVAILABLE = (
    True if find_spec("waylay.services.rules.models") is not None else False
)

if MODELS_AVAILABLE:
    from waylay.services.rules.queries.task_nodes_api import PostQuery


# some mappings that are needed for some <example> interpolations
null, true, false = None, True, False


@pytest.fixture
def task_nodes_api(waylay_api_client: ApiClient) -> TaskNodesApi:
    return TaskNodesApi(waylay_api_client)


def test_registered(waylay_client: WaylayClient):
    """Test that TaskNodesApi api is registered in the sdk client."""
    assert isinstance(waylay_client.rules.task_nodes, TaskNodesApi)


def _get_states_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, taskId: str, nodeId: str
):
    mock_response = None
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(
            f"^{gateway_url}/rules/v1/tasks/{taskId}/nodes/{nodeId}/states(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_get_states(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_states
    Get Supported States
    """
    # set path params
    taskId = "task_id_example"

    nodeId = "node_id_example"

    kwargs = {}
    _get_states_set_mock_response(
        httpx_mock, gateway_url, quote(str(taskId)), quote(str(nodeId))
    )
    resp = await service.task_nodes.get_states(taskId, nodeId, **kwargs)
    check_type(resp, Union[object,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_get_states_without_types(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_states with models not installed
    Get Supported States
    """
    # set path params
    taskId = "task_id_example"

    nodeId = "node_id_example"

    kwargs = {}
    _get_states_set_mock_response(
        httpx_mock, gateway_url, quote(str(taskId)), quote(str(nodeId))
    )
    resp = await service.task_nodes.get_states(taskId, nodeId, **kwargs)
    check_type(resp, Model)


def _get_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, taskId: str, nodeId: str
):
    mock_response = None
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(
            f"^{gateway_url}/rules/v1/tasks/{taskId}/nodes/{nodeId}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_get(service: RulesService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for get
    Get Current States
    """
    # set path params
    taskId = "task_id_example"

    nodeId = "node_id_example"

    kwargs = {}
    _get_set_mock_response(
        httpx_mock, gateway_url, quote(str(taskId)), quote(str(nodeId))
    )
    resp = await service.task_nodes.get(taskId, nodeId, **kwargs)
    check_type(resp, Union[object,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_get_without_types(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get with models not installed
    Get Current States
    """
    # set path params
    taskId = "task_id_example"

    nodeId = "node_id_example"

    kwargs = {}
    _get_set_mock_response(
        httpx_mock, gateway_url, quote(str(taskId)), quote(str(nodeId))
    )
    resp = await service.task_nodes.get(taskId, nodeId, **kwargs)
    check_type(resp, Model)


def _patch_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, taskId: str, nodeId: str
):
    mock_response = None
    httpx_mock_kwargs = {
        "method": "PATCH",
        "url": re.compile(
            f"^{gateway_url}/rules/v1/tasks/{taskId}/nodes/{nodeId}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_patch(service: RulesService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for patch
    Set Node State
    """
    # set path params
    taskId = "task_id_example"

    nodeId = "node_id_example"

    kwargs = {
        "json": NodeStateSpecificationStub.create_instance(),
    }
    _patch_set_mock_response(
        httpx_mock, gateway_url, quote(str(taskId)), quote(str(nodeId))
    )
    resp = await service.task_nodes.patch(taskId, nodeId, **kwargs)
    check_type(resp, Union[object,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_patch_without_types(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for patch with models not installed
    Set Node State
    """
    # set path params
    taskId = "task_id_example"

    nodeId = "node_id_example"

    kwargs = {
        "json": NodeStateSpecificationStub.create_json(),
    }
    _patch_set_mock_response(
        httpx_mock, gateway_url, quote(str(taskId)), quote(str(nodeId))
    )
    resp = await service.task_nodes.patch(taskId, nodeId, **kwargs)
    check_type(resp, Model)


def _post_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str):
    mock_response = None
    httpx_mock_kwargs = {
        "method": "POST",
        "url": re.compile(f"^{gateway_url}/rules/v1/tasks/callback(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_post(service: RulesService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for post
    Finalize Asynchronous Execution With Token
    """
    # set path params
    kwargs = {
        # optionally use PostQuery to validate and reuse parameters
        "query": PostQuery(
            access_token="access_token_example",
        ),
        "content": b"some_binary_content",
        "headers": {"content-type": "application/octet-stream"},
    }
    _post_set_mock_response(httpx_mock, gateway_url)
    resp = await service.task_nodes.post(**kwargs)
    check_type(resp, Union[object,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_post_without_types(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for post with models not installed
    Finalize Asynchronous Execution With Token
    """
    # set path params
    kwargs = {
        "query": {
            "access_token": "access_token_example",
        },
        "content": b"some_binary_content",
        "headers": {"content-type": "application/octet-stream"},
    }
    _post_set_mock_response(httpx_mock, gateway_url)
    resp = await service.task_nodes.post(**kwargs)
    check_type(resp, Model)


def _update_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, taskId: str, nodeId: str
):
    mock_response = None
    httpx_mock_kwargs = {
        "method": "POST",
        "url": re.compile(
            f"^{gateway_url}/rules/v1/tasks/{taskId}/nodes/{nodeId}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_update(service: RulesService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for update
    Set Current State
    """
    # set path params
    taskId = "task_id_example"

    nodeId = "node_id_example"

    kwargs = {
        "content": b"some_binary_content",
        "headers": {"content-type": "text/plain"},
    }
    _update_set_mock_response(
        httpx_mock, gateway_url, quote(str(taskId)), quote(str(nodeId))
    )
    resp = await service.task_nodes.update(taskId, nodeId, **kwargs)
    check_type(resp, Union[object,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_update_without_types(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for update with models not installed
    Set Current State
    """
    # set path params
    taskId = "task_id_example"

    nodeId = "node_id_example"

    kwargs = {
        "content": b"some_binary_content",
        "headers": {"content-type": "text/plain"},
    }
    _update_set_mock_response(
        httpx_mock, gateway_url, quote(str(taskId)), quote(str(nodeId))
    )
    resp = await service.task_nodes.update(taskId, nodeId, **kwargs)
    check_type(resp, Model)
