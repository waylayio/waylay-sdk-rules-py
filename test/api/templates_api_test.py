# coding: utf-8
"""Waylay rules engine api tests.

This code was generated from the OpenAPI documentation of 'Waylay rules engine'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import json
import re
from importlib.util import find_spec
from typing import List, Union
from urllib.parse import quote

import pytest
from pytest_httpx import HTTPXMock
from typeguard import check_type
from waylay.sdk import ApiClient, WaylayClient
from waylay.sdk.api._models import Model
from waylay.services.rules.api import TemplatesApi
from waylay.services.rules.service import RulesService

from ..types.create_template201_response_stub import CreateTemplate201ResponseStub
from ..types.replace_template200_response_stub import ReplaceTemplate200ResponseStub
from ..types.template_details_stub import TemplateDetailsStub
from ..types.template_entity_metadata_stub import TemplateEntityMetadataStub
from ..types.template_modification_stub import TemplateModificationStub
from ..types.upgrade_plugins_templates200_response_stub import (
    UpgradePluginsTemplates200ResponseStub,
)

MODELS_AVAILABLE = (
    True if find_spec("waylay.services.rules.models") is not None else False
)

if MODELS_AVAILABLE:
    from waylay.services.rules.models import (
        CreateTemplate201Response,
        ReplaceTemplate200Response,
        TemplateDetails,
        TemplateEntityMetadata,
        UpgradePluginsTemplates200Response,
    )
    from waylay.services.rules.queries.templates_api import (
        GetQuery,
        ListQuery,
        SetQuery,
        UpgradePluginsQuery,
    )


# some mappings that are needed for some <example> interpolations
null, true, false = None, True, False


@pytest.fixture
def templates_api(waylay_api_client: ApiClient) -> TemplatesApi:
    return TemplatesApi(waylay_api_client)


def test_registered(waylay_client: WaylayClient):
    """Test that TemplatesApi api is registered in the sdk client."""
    assert isinstance(waylay_client.rules.templates, TemplatesApi)


def _create_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str):
    mock_response = CreateTemplate201ResponseStub.create_json()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": re.compile(f"^{gateway_url}/rules/v1/templates(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 201,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_create(service: RulesService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for create
    Create Template
    """
    # set path params
    kwargs = {}
    _create_set_mock_response(httpx_mock, gateway_url)
    resp = await service.templates.create(**kwargs)
    check_type(resp, Union[CreateTemplate201Response,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_create_without_types(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for create with models not installed
    Create Template
    """
    # set path params
    kwargs = {}
    _create_set_mock_response(httpx_mock, gateway_url)
    resp = await service.templates.create(**kwargs)
    check_type(resp, Model)


def _delete_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str, name: str):
    mock_response = None
    httpx_mock_kwargs = {
        "method": "DELETE",
        "url": re.compile(f"^{gateway_url}/rules/v1/templates/{name}(\\?.*)?"),
        "content": mock_response,
        "status_code": 204,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_delete(service: RulesService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for delete
    Delete Template
    """
    # set path params
    name = "name_example"

    kwargs = {}
    _delete_set_mock_response(httpx_mock, gateway_url, quote(str(name)))
    resp = await service.templates.delete(name, **kwargs)
    assert not resp


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_delete_without_types(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for delete with models not installed
    Delete Template
    """
    # set path params
    name = "name_example"

    kwargs = {}
    _delete_set_mock_response(httpx_mock, gateway_url, quote(str(name)))
    resp = await service.templates.delete(name, **kwargs)
    assert not resp


def _get_discovery_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str):
    mock_response = TemplateDetailsStub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(f"^{gateway_url}/rules/v1/discoveryTemplate(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_get_discovery(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_discovery
    Retrieve Discovery Template
    """
    # set path params
    kwargs = {}
    _get_discovery_set_mock_response(httpx_mock, gateway_url)
    resp = await service.templates.get_discovery(**kwargs)
    check_type(
        resp,
        Union[
            TemplateDetails,
            None,
        ],
    )


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_get_discovery_without_types(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_discovery with models not installed
    Retrieve Discovery Template
    """
    # set path params
    kwargs = {}
    _get_discovery_set_mock_response(httpx_mock, gateway_url)
    resp = await service.templates.get_discovery(**kwargs)
    check_type(resp, Model)


def _get_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str, name: str):
    mock_response = TemplateDetailsStub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(f"^{gateway_url}/rules/v1/templates/{name}(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_get(service: RulesService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for get
    Retrieve Template Details
    """
    # set path params
    name = "name_example"

    kwargs = {
        # optionally use GetQuery to validate and reuse parameters
        "query": GetQuery(
            format="bn",
        ),
    }
    _get_set_mock_response(httpx_mock, gateway_url, quote(str(name)))
    resp = await service.templates.get(name, **kwargs)
    check_type(resp, Union[TemplateDetails,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_get_without_types(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get with models not installed
    Retrieve Template Details
    """
    # set path params
    name = "name_example"

    kwargs = {
        "query": {
            "format": "bn",
        },
    }
    _get_set_mock_response(httpx_mock, gateway_url, quote(str(name)))
    resp = await service.templates.get(name, **kwargs)
    check_type(resp, Model)


def _list_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str):
    mock_response = [TemplateEntityMetadataStub.create_json()]
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(f"^{gateway_url}/rules/v1/templates(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_list(service: RulesService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for list
    List Templates
    """
    # set path params
    kwargs = {
        # optionally use ListQuery to validate and reuse parameters
        "query": ListQuery(
            hits=10,
            start_index=0,
            filter="filter_example",
            ids=[],
            id="id_example",
            plugin="mySensor:1.0.3",
            tags_x="tags.myref: 3904859080956",
        ),
    }
    _list_set_mock_response(httpx_mock, gateway_url)
    resp = await service.templates.list(**kwargs)
    check_type(resp, Union[List[TemplateEntityMetadata],])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_list_without_types(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for list with models not installed
    List Templates
    """
    # set path params
    kwargs = {
        "query": {
            "hits": 10,
            "startIndex": 0,
            "filter": "filter_example",
            "ids": [],
            "id": "id_example",
            "plugin": "mySensor:1.0.3",
            "tags.X": "tags.myref: 3904859080956",
        },
    }
    _list_set_mock_response(httpx_mock, gateway_url)
    resp = await service.templates.list(**kwargs)
    check_type(resp, Model)


def _replace_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str, name: str):
    mock_response = ReplaceTemplate200ResponseStub.create_json()
    httpx_mock_kwargs = {
        "method": "PUT",
        "url": re.compile(f"^{gateway_url}/rules/v1/templates/{name}(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_replace(service: RulesService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for replace
    Update Template
    """
    # set path params
    name = "name_example"

    kwargs = {}
    _replace_set_mock_response(httpx_mock, gateway_url, quote(str(name)))
    resp = await service.templates.replace(name, **kwargs)
    check_type(resp, Union[ReplaceTemplate200Response,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_replace_without_types(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for replace with models not installed
    Update Template
    """
    # set path params
    name = "name_example"

    kwargs = {}
    _replace_set_mock_response(httpx_mock, gateway_url, quote(str(name)))
    resp = await service.templates.replace(name, **kwargs)
    check_type(resp, Model)


def _set_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str):
    mock_response = TemplateDetailsStub.create_json()
    httpx_mock_kwargs = {
        "method": "PUT",
        "url": re.compile(f"^{gateway_url}/rules/v1/discoveryTemplate(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_set(service: RulesService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for set
    Set Discovery Template
    """
    # set path params
    kwargs = {
        # optionally use SetQuery to validate and reuse parameters
        "query": SetQuery(
            name="discoverResourceType",
        ),
    }
    _set_set_mock_response(httpx_mock, gateway_url)
    resp = await service.templates.set(**kwargs)
    check_type(
        resp,
        Union[
            TemplateDetails,
            None,
        ],
    )


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_set_without_types(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for set with models not installed
    Set Discovery Template
    """
    # set path params
    kwargs = {
        "query": {
            "name": "discoverResourceType",
        },
    }
    _set_set_mock_response(httpx_mock, gateway_url)
    resp = await service.templates.set(**kwargs)
    check_type(resp, Model)


def _upgrade_plugins_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str):
    mock_response = UpgradePluginsTemplates200ResponseStub.create_json()
    httpx_mock_kwargs = {
        "method": "PATCH",
        "url": re.compile(f"^{gateway_url}/rules/v1/templates(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_upgrade_plugins(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for upgrade_plugins
    Upgrade Plugins
    """
    # set path params
    kwargs = {
        # optionally use UpgradePluginsQuery to validate and reuse parameters
        "query": UpgradePluginsQuery(
            ids=["internet.json"],
            id="id_example",
            plugin='{"plugin":"mySensor:1.0.3"}',
            tags_x="tags_x_example",
        ),
        "json": TemplateModificationStub.create_instance(),
    }
    _upgrade_plugins_set_mock_response(httpx_mock, gateway_url)
    resp = await service.templates.upgrade_plugins(**kwargs)
    check_type(resp, Union[UpgradePluginsTemplates200Response,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_upgrade_plugins_without_types(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for upgrade_plugins with models not installed
    Upgrade Plugins
    """
    # set path params
    kwargs = {
        "query": {
            "ids": ["internet.json"],
            "id": "id_example",
            "plugin": '{"plugin":"mySensor:1.0.3"}',
            "tags.X": "tags_x_example",
        },
        "json": TemplateModificationStub.create_json(),
    }
    _upgrade_plugins_set_mock_response(httpx_mock, gateway_url)
    resp = await service.templates.upgrade_plugins(**kwargs)
    check_type(resp, Model)
