# coding: utf-8
"""Waylay rules engine api tests.

This code was generated from the OpenAPI documentation of 'Waylay rules engine'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import json
import re
from importlib.util import find_spec
from typing import List, Union
from urllib.parse import quote

import pytest
from pytest_httpx import HTTPXMock
from typeguard import check_type
from waylay.sdk import ApiClient, WaylayClient
from waylay.sdk.api._models import Model
from waylay.services.rules.api import TasksApi
from waylay.services.rules.service import RulesService

from ..types.create_task201_response_stub import CreateTask201ResponseStub
from ..types.list_tasks_tags_key_parameter_stub import ListTasksTagsKeyParameterStub
from ..types.task_entity_stub import TaskEntityStub
from ..types.task_specification_stub import TaskSpecificationStub

MODELS_AVAILABLE = (
    True if find_spec("waylay.services.rules.models") is not None else False
)

if MODELS_AVAILABLE:
    from waylay.services.rules.models import (
        CreateTask201Response,
        TaskEntity,
        TaskSpecification,
    )
    from waylay.services.rules.queries.tasks_api import (
        CreateQuery,
        GetConfigurationQuery,
        GetQuery,
        ListQuery,
    )


# some mappings that are needed for some <example> interpolations
null, true, false = None, True, False


@pytest.fixture
def tasks_api(waylay_api_client: ApiClient) -> TasksApi:
    return TasksApi(waylay_api_client)


def test_registered(waylay_client: WaylayClient):
    """Test that TasksApi api is registered in the sdk client."""
    assert isinstance(waylay_client.rules.tasks, TasksApi)


def _create_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str):
    mock_response = CreateTask201ResponseStub.create_json()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": re.compile(f"^{gateway_url}/rules/v1/tasks(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 201,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_create(service: RulesService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for create
    Create Task
    """
    # set path params
    kwargs = {
        # optionally use CreateQuery to validate and reuse parameters
        "query": CreateQuery(
            fail_on_warning=False,
            return_warnings=False,
        ),
        "json": TaskSpecificationStub.create_instance(),
    }
    _create_set_mock_response(httpx_mock, gateway_url)
    resp = await service.tasks.create(**kwargs)
    check_type(resp, Union[CreateTask201Response,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_create_without_types(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for create with models not installed
    Create Task
    """
    # set path params
    kwargs = {
        "query": {
            "failOnWarning": False,
            "returnWarnings": False,
        },
        "json": TaskSpecificationStub.create_json(),
    }
    _create_set_mock_response(httpx_mock, gateway_url)
    resp = await service.tasks.create(**kwargs)
    check_type(resp, Model)


def _delete_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str, taskId: str):
    mock_response = None
    httpx_mock_kwargs = {
        "method": "DELETE",
        "url": re.compile(f"^{gateway_url}/rules/v1/tasks/{taskId}(\\?.*)?"),
        "content": mock_response,
        "status_code": 204,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_delete(service: RulesService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for delete
    Delete Task
    """
    # set path params
    taskId = "task_id_example"

    kwargs = {}
    _delete_set_mock_response(httpx_mock, gateway_url, quote(str(taskId)))
    resp = await service.tasks.delete(taskId, **kwargs)
    assert not resp


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_delete_without_types(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for delete with models not installed
    Delete Task
    """
    # set path params
    taskId = "task_id_example"

    kwargs = {}
    _delete_set_mock_response(httpx_mock, gateway_url, quote(str(taskId)))
    resp = await service.tasks.delete(taskId, **kwargs)
    assert not resp


def _get_configuration_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, taskId: str
):
    mock_response = TaskSpecificationStub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(f"^{gateway_url}/rules/v1/tasks/{taskId}/conf(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_get_configuration(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_configuration
    Get Task Configuration
    """
    # set path params
    taskId = "task_id_example"

    kwargs = {
        # optionally use GetConfigurationQuery to validate and reuse parameters
        "query": GetConfigurationQuery(
            format="bn",
        ),
    }
    _get_configuration_set_mock_response(httpx_mock, gateway_url, quote(str(taskId)))
    resp = await service.tasks.get_configuration(taskId, **kwargs)
    check_type(resp, Union[TaskSpecification,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_get_configuration_without_types(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_configuration with models not installed
    Get Task Configuration
    """
    # set path params
    taskId = "task_id_example"

    kwargs = {
        "query": {
            "format": "bn",
        },
    }
    _get_configuration_set_mock_response(httpx_mock, gateway_url, quote(str(taskId)))
    resp = await service.tasks.get_configuration(taskId, **kwargs)
    check_type(resp, Model)


def _get_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str, taskId: str):
    mock_response = TaskEntityStub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(f"^{gateway_url}/rules/v1/tasks/{taskId}(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_get(service: RulesService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for get
    Retrieve Task Details
    """
    # set path params
    taskId = "task_id_example"

    kwargs = {
        # optionally use GetQuery to validate and reuse parameters
        "query": GetQuery(
            format="bn",
        ),
    }
    _get_set_mock_response(httpx_mock, gateway_url, quote(str(taskId)))
    resp = await service.tasks.get(taskId, **kwargs)
    check_type(resp, Union[TaskEntity,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_get_without_types(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get with models not installed
    Retrieve Task Details
    """
    # set path params
    taskId = "task_id_example"

    kwargs = {
        "query": {
            "format": "bn",
        },
    }
    _get_set_mock_response(httpx_mock, gateway_url, quote(str(taskId)))
    resp = await service.tasks.get(taskId, **kwargs)
    check_type(resp, Model)


def _list_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str):
    mock_response = [TaskEntityStub.create_json()]
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(f"^{gateway_url}/rules/v1/tasks(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_list(service: RulesService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for list
    Query Multiple Tasks
    """
    # set path params
    kwargs = {
        # optionally use ListQuery to validate and reuse parameters
        "query": ListQuery(
            hits=10,
            start_index=0,
            format="bn",
            name="name_example",
            resource="resource_example",
            resource_type="resource_type_example",
            type="scheduled",
            status="running",
            ids=[],
            id="id_example",
            plugin="plugin_example",
            template="template_example",
            filter="filter_example",
            tags_key=ListTasksTagsKeyParameterStub.create_json(),
            finished_before=56,
            created_after=1661990400000,
            created_before=1662768000000,
        ),
    }
    _list_set_mock_response(httpx_mock, gateway_url)
    resp = await service.tasks.list(**kwargs)
    check_type(resp, Union[List[TaskEntity],])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_list_without_types(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for list with models not installed
    Query Multiple Tasks
    """
    # set path params
    kwargs = {
        "query": {
            "hits": 10,
            "startIndex": 0,
            "format": "bn",
            "name": "name_example",
            "resource": "resource_example",
            "resourceType": "resource_type_example",
            "type": "scheduled",
            "status": "running",
            "ids": [],
            "id": "id_example",
            "plugin": "plugin_example",
            "template": "template_example",
            "filter": "filter_example",
            "tags.key": ListTasksTagsKeyParameterStub.create_json(),
            "finishedBefore": 56,
            "createdAfter": 1661990400000,
            "createdBefore": 1662768000000,
        },
    }
    _list_set_mock_response(httpx_mock, gateway_url)
    resp = await service.tasks.list(**kwargs)
    check_type(resp, Model)


def _replace_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str, taskId: str):
    mock_response = TaskEntityStub.create_json()
    httpx_mock_kwargs = {
        "method": "PUT",
        "url": re.compile(f"^{gateway_url}/rules/v1/tasks/{taskId}(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_replace(service: RulesService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for replace
    Update Task
    """
    # set path params
    taskId = "task_id_example"

    kwargs = {
        "json": TaskSpecificationStub.create_instance(),
    }
    _replace_set_mock_response(httpx_mock, gateway_url, quote(str(taskId)))
    resp = await service.tasks.replace(taskId, **kwargs)
    check_type(resp, Union[TaskEntity,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_replace_without_types(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for replace with models not installed
    Update Task
    """
    # set path params
    taskId = "task_id_example"

    kwargs = {
        "json": TaskSpecificationStub.create_json(),
    }
    _replace_set_mock_response(httpx_mock, gateway_url, quote(str(taskId)))
    resp = await service.tasks.replace(taskId, **kwargs)
    check_type(resp, Model)


def _start_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str, taskId: str):
    mock_response = TaskEntityStub.create_json()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": re.compile(
            f"^{gateway_url}/rules/v1/tasks/{taskId}/command/start(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_start(service: RulesService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for start
    Start Task
    """
    # set path params
    taskId = "task_id_example"

    kwargs = {}
    _start_set_mock_response(httpx_mock, gateway_url, quote(str(taskId)))
    resp = await service.tasks.start(taskId, **kwargs)
    check_type(resp, Union[TaskEntity,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_start_without_types(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for start with models not installed
    Start Task
    """
    # set path params
    taskId = "task_id_example"

    kwargs = {}
    _start_set_mock_response(httpx_mock, gateway_url, quote(str(taskId)))
    resp = await service.tasks.start(taskId, **kwargs)
    check_type(resp, Model)


def _stop_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str, taskId: str):
    mock_response = TaskEntityStub.create_json()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": re.compile(
            f"^{gateway_url}/rules/v1/tasks/{taskId}/command/stop(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_stop(service: RulesService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for stop
    Stop Task
    """
    # set path params
    taskId = "task_id_example"

    kwargs = {}
    _stop_set_mock_response(httpx_mock, gateway_url, quote(str(taskId)))
    resp = await service.tasks.stop(taskId, **kwargs)
    check_type(resp, Union[TaskEntity,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_stop_without_types(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for stop with models not installed
    Stop Task
    """
    # set path params
    taskId = "task_id_example"

    kwargs = {}
    _stop_set_mock_response(httpx_mock, gateway_url, quote(str(taskId)))
    resp = await service.tasks.stop(taskId, **kwargs)
    check_type(resp, Model)
