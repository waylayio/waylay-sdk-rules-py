# coding: utf-8
"""Waylay rules engine api tests.

This code was generated from the OpenAPI documentation of 'Waylay rules engine'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import json
import re
from importlib.util import find_spec
from typing import Union
from urllib.parse import quote

import pytest
from pytest_httpx import HTTPXMock
from typeguard import check_type
from waylay.sdk import ApiClient, WaylayClient
from waylay.sdk.api._models import Model
from waylay.services.rules.api import PlugsExecutionApi
from waylay.services.rules.service import RulesService

from ..types.actuator_execution_result_stub import ActuatorExecutionResultStub
from ..types.execute_plugs_specification_stub import ExecutePlugsSpecificationStub
from ..types.sensor_execution_result_stub import SensorExecutionResultStub
from ..types.transformer_execution_result_stub import TransformerExecutionResultStub

MODELS_AVAILABLE = (
    True if find_spec("waylay.services.rules.models") is not None else False
)

if MODELS_AVAILABLE:
    from waylay.services.rules.models import (
        ActuatorExecutionResult,
        SensorExecutionResult,
        TransformerExecutionResult,
    )


# some mappings that are needed for some <example> interpolations
null, true, false = None, True, False


@pytest.fixture
def plugs_execution_api(waylay_api_client: ApiClient) -> PlugsExecutionApi:
    return PlugsExecutionApi(waylay_api_client)


def test_registered(waylay_client: WaylayClient):
    """Test that PlugsExecutionApi api is registered in the sdk client."""
    assert isinstance(waylay_client.rules.plugs_execution, PlugsExecutionApi)


def _execute_actuator_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str
):
    mock_response = ActuatorExecutionResultStub.create_json()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": re.compile(f"^{gateway_url}/rules/v1/actions/{name}(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_execute_actuator(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for execute_actuator
    Execute Latest Actuator Version
    """
    # set path params
    name = "name_example"

    kwargs = {
        "json": ExecutePlugsSpecificationStub.create_instance(),
    }
    _execute_actuator_set_mock_response(httpx_mock, gateway_url, quote(str(name)))
    resp = await service.plugs_execution.execute_actuator(name, **kwargs)
    check_type(resp, Union[ActuatorExecutionResult,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_execute_actuator_without_types(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for execute_actuator with models not installed
    Execute Latest Actuator Version
    """
    # set path params
    name = "name_example"

    kwargs = {
        "json": ExecutePlugsSpecificationStub.create_json(),
    }
    _execute_actuator_set_mock_response(httpx_mock, gateway_url, quote(str(name)))
    resp = await service.plugs_execution.execute_actuator(name, **kwargs)
    check_type(resp, Model)


def _execute_actuator_version_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str
):
    mock_response = ActuatorExecutionResultStub.create_json()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": re.compile(
            f"^{gateway_url}/rules/v1/actions/{name}/versions/{version}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_execute_actuator_version(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for execute_actuator_version
    Execute Specified Actuator Version
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "json": ExecutePlugsSpecificationStub.create_instance(),
    }
    _execute_actuator_version_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.plugs_execution.execute_actuator_version(
        name, version, **kwargs
    )
    check_type(resp, Union[ActuatorExecutionResult,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_execute_actuator_version_without_types(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for execute_actuator_version with models not installed
    Execute Specified Actuator Version
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "json": ExecutePlugsSpecificationStub.create_json(),
    }
    _execute_actuator_version_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.plugs_execution.execute_actuator_version(
        name, version, **kwargs
    )
    check_type(resp, Model)


def _execute_sensor_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str
):
    mock_response = SensorExecutionResultStub.create_json()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": re.compile(f"^{gateway_url}/rules/v1/sensors/{name}(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_execute_sensor(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for execute_sensor
    Execute Latest Sensor Version
    """
    # set path params
    name = "name_example"

    kwargs = {
        "json": ExecutePlugsSpecificationStub.create_instance(),
    }
    _execute_sensor_set_mock_response(httpx_mock, gateway_url, quote(str(name)))
    resp = await service.plugs_execution.execute_sensor(name, **kwargs)
    check_type(resp, Union[SensorExecutionResult,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_execute_sensor_without_types(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for execute_sensor with models not installed
    Execute Latest Sensor Version
    """
    # set path params
    name = "name_example"

    kwargs = {
        "json": ExecutePlugsSpecificationStub.create_json(),
    }
    _execute_sensor_set_mock_response(httpx_mock, gateway_url, quote(str(name)))
    resp = await service.plugs_execution.execute_sensor(name, **kwargs)
    check_type(resp, Model)


def _execute_sensor_version_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str
):
    mock_response = SensorExecutionResultStub.create_json()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": re.compile(
            f"^{gateway_url}/rules/v1/sensors/{name}/versions/{version}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_execute_sensor_version(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for execute_sensor_version
    Execute Specified Sensor Version
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "json": ExecutePlugsSpecificationStub.create_instance(),
    }
    _execute_sensor_version_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.plugs_execution.execute_sensor_version(name, version, **kwargs)
    check_type(resp, Union[SensorExecutionResult,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_execute_sensor_version_without_types(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for execute_sensor_version with models not installed
    Execute Specified Sensor Version
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "json": ExecutePlugsSpecificationStub.create_json(),
    }
    _execute_sensor_version_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.plugs_execution.execute_sensor_version(name, version, **kwargs)
    check_type(resp, Model)


def _execute_transformer_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str
):
    mock_response = TransformerExecutionResultStub.create_json()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": re.compile(f"^{gateway_url}/rules/v1/transformers/{name}(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_execute_transformer(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for execute_transformer
    Execute Latest Transformer Version
    """
    # set path params
    name = "name_example"

    kwargs = {
        "json": ExecutePlugsSpecificationStub.create_instance(),
    }
    _execute_transformer_set_mock_response(httpx_mock, gateway_url, quote(str(name)))
    resp = await service.plugs_execution.execute_transformer(name, **kwargs)
    check_type(resp, Union[TransformerExecutionResult,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_execute_transformer_without_types(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for execute_transformer with models not installed
    Execute Latest Transformer Version
    """
    # set path params
    name = "name_example"

    kwargs = {
        "json": ExecutePlugsSpecificationStub.create_json(),
    }
    _execute_transformer_set_mock_response(httpx_mock, gateway_url, quote(str(name)))
    resp = await service.plugs_execution.execute_transformer(name, **kwargs)
    check_type(resp, Model)


def _execute_transformer_version_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, name: str, version: str
):
    mock_response = TransformerExecutionResultStub.create_json()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": re.compile(
            f"^{gateway_url}/rules/v1/transformers/{name}/versions/{version}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_execute_transformer_version(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for execute_transformer_version
    Execute Specified Transformer Version
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "json": ExecutePlugsSpecificationStub.create_instance(),
    }
    _execute_transformer_version_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.plugs_execution.execute_transformer_version(
        name, version, **kwargs
    )
    check_type(resp, Union[TransformerExecutionResult,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_execute_transformer_version_without_types(
    service: RulesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for execute_transformer_version with models not installed
    Execute Specified Transformer Version
    """
    # set path params
    name = "name_example"

    version = "version_example"

    kwargs = {
        "json": ExecutePlugsSpecificationStub.create_json(),
    }
    _execute_transformer_version_set_mock_response(
        httpx_mock, gateway_url, quote(str(name)), quote(str(version))
    )
    resp = await service.plugs_execution.execute_transformer_version(
        name, version, **kwargs
    )
    check_type(resp, Model)
